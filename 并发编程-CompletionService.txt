一、概述
首先CompletionService结合了Executor和BlockingQueue，大概就是实现了异步过程。

二、具体方法
1、submit(callable)



提交线程到线程池，如果提交被拒绝将会抛出RejectedExecutionException。
这个异常是线程池抛出来的，具体可以看线程池的构造方法，以及相关的几个拒绝提交处理器。
https://blog.csdn.net/izard999/article/details/8552681?readlog

2、submit(runnable)



这个方法和第一个方法唯一的不同就是提交的是 runnable的线程，但是第二个参数：result的作用还未知。

3、take和poll



两者都是用来获取有结果的Future的，不一样的地方是take是阻塞方法，poll不是，如果当前没有任务完成了，poll会直接返回null。
不过下面poll 方法还有一个可以传等待时间的实现，那个是阻塞方法。

问题：如果后提交的任务先完成了，内部的BlockingQueue是怎么实现重排序的？




看这个take方法，感觉并不会先返回已经完成的任务啊

原来是这样的：completionQueue 其实是 已经完成的任务队列
CompletionService 会给每一个任务 单独建一个FutureTask，然后这个Future结束的时候，才会把任务加入到 completionQueue 队列里面去。
这就达到了先完成的任务先取出来，如果没有任务完成将会一直阻塞的结果。






应用场景：前端加载界面，有很多元素或者是图片需要加载，先加载出来的可以先渲染。


