从本章开始将会介绍到，当有多个多个任务需要提交线程的时候，我们可以怎么去处理，怎么样从使得系统的容量和任务之间达到一个平衡

一、从Servlet 到 线程池
1、串行的Servlet 
就是只有一个线程来处理任务，如下：


一些GUI 还是使用单线程来运行的，为什么呢？
https://blog.csdn.net/liuqiaoyu080512/article/details/12895005
但是看完还是有点蒙蔽。。为什么反向就要加锁来搞呢？

2、手动创建线程池 和 通过Executor 来创建线程池
手动创建的话因为线程数量不受到控制，所以肯定是不推荐的。
通过Executor 创建线程池，可以设置线程的最大数量这样的。

---> JVM 、 Linux 系统 对最大线程数量是怎么限制的？
https://blog.csdn.net/gatieme/article/details/51058797




---> 这个下来看下JVM的相关

3、Executor 的生命周期
这里书本就介绍了shutdown 方法和 shutdownNow方法

Shutdown 可以平滑关闭线程池，会等待所有的线程（包括等待队列中的）都执行完成之后才结束
ShutdownNow，则是直接关闭。

---> 线程池的生命周期不会只有这些吧。。。
https://blog.csdn.net/u010412719/article/details/52132601
确实不只有这些，还有几种状态的。
但是其实从设计上来看都不用怎么关心，我们要控制线程池周期的话一般也只用一个shutdown就够了。

4、提交定时任务
这里介绍了两种方式：Timer和SchedulerThreadPoolExecutor
Timer有一个不好的地方是：如果在一个周期当中，Timer的任务执行出现问题的话，接下来都不会重复执行，Timer直接认为整个任务都被取消掉了。
这种问题叫做线程泄漏。
---> 看了一下博客（https://www.ibm.com/developerworks/cn/java/j-jtp0924/index.html），还是有点不明白是什么情况。

所以推荐还是用线程池：SchedulerThreadPoolExecutor

二、实现一个高效的渲染器
最终目标是实现一个可以一边加载文本，一边还可以加载图像这样高效的渲染器。
文本和图像分开加载是很简单实现的
但是如何保证 每一个图像加载成功之后，都能够渲染到主页上。

这个时候用到了一个 CompletionService：结合了Executor和BlockingQueue的方法。

三、定时任务
Future.get方法：可以设置定时，如果超过某段时间没有返回，将会抛出TimeoutException异常。


四、提交一组任务
invokeAll方法：提交一组方法，并获取一组Future。
