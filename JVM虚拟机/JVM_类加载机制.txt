输入：Class 文件
输出：加载到内存当中的类数据

一、类的生命周期

（截图：类的生命周期）



1、加载阶段

类什么时候开始加载：（也就是什么时候开始用到这个类的时候）
New
静态方法
反射
加载子类的时候，父类如果没加载过，会进行加载
Main() 方法对应的主类

类加载相关的一些问题
① 子类引用父类的静态变量，父类是一定要初始化的，但是子类不需要

② 读取非父类的静态常量，非父类并不需要初始化，因为常量是放到常量池里面去的。而且常量池本身有一个NotInitialization 类，所有常量的引用都会指向这个类

③ 定义数组：数组的类型对应的类本身也不需要初始化（因为数组里面的类型是引用？）

其实加载就是将类 翻译成运行时的数据结构
然后数据保存在方法区

2、验证过程
需要验证的数据：
比如Class的版本：低版本的JDK不能加载高版本的class文件
class文件的基本格式（怎么检查？）

真正过程：
1） 文件格式验证
魔数、版本号、编码格式等等
2）元数据验证
检验class 里面的数据是否符合java 的基本定义。编译阶段的错误应该都在这里能发现。
比如是否继承了final 的方法
3）字节码验证
验证一些变量的基本格式，比如强转
4）符号引用
方法名称、方法的访问性是否正确

总之验证过程主要还是解决编译期间的问题。

3、准备
数据的初始化阶段
对非final static 静态成员默认有一个初始值（手动赋值的不算，那种是要在加载类的时候才会初始化）

4、解析
对不同的类类型进行解析，进行后续初始化的准备
（不是加载到方法区的时候已经知道这些类型需要多少大小了吗？是因为大小还没分配？）

5、初始化



其他相关问题
问题① 类构造器clinit和方法构造器init 的区别

问题② 父类和子类数据加载的关系

二、类加载器
1、类和类加载器
结论：即使是同一个类，但是如果使用不同的类加载器，最后生成的类都是不同的

2、双亲委派模型
这个在前面的章节已经提到了

但是书上说到的这个自己测试了一下其实是不会出现的？
（截图：定义和rt.jar 里面的类同名的，能编译成功但是无法运行；实际：可以运行）



3、破坏双亲委派模型

问题③ 虚拟机对类的热加载是怎么实现的？
参考博客：https://yq.aliyun.com/articles/65023

tomcat的实现方式：
WebappClassLoader重写了findLoadedClass0()、findClass()方法，主要是在更改的逻辑在于：自己优先加载class文件，然后根据情况决定是否由父类加载；自定义缓存机制来缓存自己已经加载的class资源。

JDK 1.4 之后的实现方式：
在Play context重启的时候会重新创建一个新的ApplicationClassLoader实例来加载所有的资源文件、class文件。之前的ClassLoader实例及相关被加载的资源都被丢弃有jvm gc回收。

Play1通过Instrumentation.redefineClasses方法一定程度上减少class文件修改导致的context重新加载问题，但是在实际开发场景中意义不大：class文件和资源文件经常有较大的变化；热加载后类的静态属性不能初始化；不支持spring、ibatis等常见框架。。。
