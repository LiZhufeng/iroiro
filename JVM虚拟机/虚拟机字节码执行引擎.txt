从这里开始要讲执行的过程了
可参考的其他博客：
https://segmentfault.com/a/1190000016148868

一、运行时的栈帧结构
（截图：P200，栈帧结构）


指针+开辟一块空间？

1、局部变量表
https://blog.csdn.net/keda8997110/article/details/19480769

这里要提到一个Slot作用域的概念

{ 
byte b = new byte[6 * 1024 * 1024]; 
} 
int a = 0; 


比如这样一段代码，b 才能够被GC 回收掉

因为在执行 a = 0 的时候，当前字节码的PC计数器的值已经超出了整个变量的作用域，那么这个变量对应的slot既可以交给其它的变量使用。

相反：
byte[] waste = new byte[6 * 1024 * 1024];  
    int new_var = 0;  
    System.gc(); 

这种情况下，waste 和 new_var 都是在同一个作用域当中，那么 gc 就不会回收waste。

2、操作数栈
进行数据计算的时候用的
FIFO
不同的栈帧之间可以共享一部分数据（两个线程之间？）

3、动态连接
对比：静态连接
都是指对常量池中对象的引用

4、方法返回地址
也就是出栈的一些操作
数据的恢复、返回值存入调用者栈帧、将PC计数器的值指向方法的后一条指令等等

回顾：可以联想到一个方法被调用过程中的执行过程：
（加粗）
① 局部变量被加载到内存中
② 执行过程：如果需要进行计算，则使用操作数栈进行
③ 执行过程：动态连接（运行期间直接饮用）和静态连接（第一次使用/类加载阶段）
④ 执行完成：返回地址

二、方法调用
1、解析过程
在代码编译期间，一些方法的调用方式就已经可以确认下来
调用方法主要有下面4个字节码指令（截图）




扩展：查看字节码的方法：javap -verbose 类名

2、分派
解析过程只是对简单的方法调用方式的解析，而分派过程就涉及到类的一些继承情况
1）静态分派
场景① 方法重载
（截图：分派代码）

静态类型：程序在编译过程中确定

实际类型：程序在运行中确定

继承情况下，实际调用的方法是在编译期就确定好的，也就是通过静态类型来确定。而不是动态类型。（这样做也确实省事）


扩展：静态内部类

2）动态分派
场景① 方法重写
这时就要说到继承了，要用到哪个方法肯定要看对象的实际类型的。

3）单分派和多分派
静态多分派、动态单分派

4）动态分派的实现方式
（截图：8-3：方法表结构）

核心：同名方法的地址替换

扩展：内联缓存和守护内联，后续优化

三、基于栈的字节码解释执行引擎
1、解释执行
2、








